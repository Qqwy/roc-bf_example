procedure : `Str.fromUtf8` [C {U64, U8}, C Str]
procedure = `Str.fromUtf8` (`Str.bytes`: List U8):
    let `Str.315` : U64 = 0i64;
    let `Str.316` : U64 = CallByName `List.len` `Str.bytes`;
    let `Str.result` : {U64, Str, Int1, U8} = CallByName `Str.fromUtf8RangeLowlevel` `Str.bytes` `Str.315` `Str.316`;
    let `Str.312` : Int1 = StructAtIndex 2 `Str.result`;
    if `Str.312` then
        let `Str.314` : Str = StructAtIndex 1 `Str.result`;
        let `Str.313` : [C {U64, U8}, C Str] = TagId(1) `Str.314`;
        ret `Str.313`;
    else
        let `Str.310` : U8 = StructAtIndex 3 `Str.result`;
        let `Str.311` : U64 = StructAtIndex 0 `Str.result`;
        let `Bool.IdentId(41)` : Str = StructAtIndex 1 `Str.result`;
        dec `Bool.IdentId(41)`;
        let `Str.309` : {U64, U8} = Struct {`Str.311`, `Str.310`};
        let `Str.308` : [C {U64, U8}, C Str] = TagId(0) `Str.309`;
        ret `Str.308`;

procedure : `pf.Effect.stdoutLine` Str
procedure = `pf.Effect.stdoutLine` (`pf.Effect.closure_arg_stdoutLine_0`: Str):
    ret `pf.Effect.closure_arg_stdoutLine_0`;

procedure : `Bool.structuralNotEq` Int1
procedure = `Bool.structuralNotEq` (`#Attr.#arg1`: U8, `#Attr.#arg2`: U8):
    let `Bool.25` : Int1 = lowlevel NotEq `#Attr.#arg1` `#Attr.#arg2`;
    ret `Bool.25`;

procedure : `pf..roc__getter__1` {}
procedure = `pf..roc__getter__1` (`pf..8`: [<rnnu>C {Str, {}}]):
    let `pf..9` : {Str, {}} = UnionAtIndex (Id 0) (Index 0) `pf..8`;
    inc `pf..9`;
    dec `pf..8`;
    let `pf..10` : {} = StructAtIndex 1 `pf..9`;
    let `Bool.IdentId(42)` : Str = StructAtIndex 0 `pf..9`;
    dec `Bool.IdentId(42)`;
    ret `pf..10`;

procedure : `pf..mainForHost` {Str, {}}
procedure = `pf..mainForHost` ():
    let `pf..2` : {Str, {}} = CallByName `#UserApp.main`;
    ret `pf..2`;

procedure : `List.get` [C {}, C U8]
procedure = `List.get` (`List.list`: List U8, `List.index`: U64):
    let `List.601` : U64 = CallByName `List.len` `List.list`;
    let `List.598` : Int1 = CallByName `Num.isLt` `List.index` `List.601`;
    if `List.598` then
        let `List.600` : U8 = CallByName `List.getUnsafe` `List.list` `List.index`;
        dec `List.list`;
        let `List.599` : [C {}, C U8] = TagId(1) `List.600`;
        ret `List.599`;
    else
        dec `List.list`;
        let `List.597` : {} = Struct {};
        let `List.596` : [C {}, C U8] = TagId(0) `List.597`;
        ret `List.596`;

procedure : `#UserApp.tokenize` List [C , C , C , C U64, C U64, C , C , C ]
procedure = `#UserApp.tokenize` (`#UserApp.bytes`: List U8):
    let `#UserApp.302` : U64 = 0i64;
    let `#UserApp.303` : List [C , C , C , C U64, C U64, C , C , C ] = Array [];
    let `#UserApp.304` : List U64 = Array [];
    let `#UserApp.beginState` : {U64, List [C , C , C , C U64, C U64, C , C , C ], List U64} = Struct {`#UserApp.302`, `#UserApp.303`, `#UserApp.304`};
    let `#UserApp.229` : {} = Struct {};
    let `#UserApp.228` : {U64, List [C , C , C , C U64, C U64, C , C , C ], List U64} = CallByName `List.walk` `#UserApp.bytes` `#UserApp.beginState` `#UserApp.229`;
    let `#UserApp.instructions` : List [C , C , C , C U64, C U64, C , C , C ] = StructAtIndex 1 `#UserApp.228`;
    let `Bool.IdentId(43)` : List U64 = StructAtIndex 2 `#UserApp.228`;
    dec `Bool.IdentId(43)`;
    ret `#UserApp.instructions`;

procedure : `pf.Effect.effect_map_inner` {}
procedure = `pf.Effect.effect_map_inner` (`pf.Effect.105`: {}, `#Attr.#arg_closure`: {Str, {}}):
    let `pf.Effect.effect_map_mapper` : {} = StructAtIndex 1 `#Attr.#arg_closure`;
    let `pf.Effect.effect_map_thunk` : Str = StructAtIndex 0 `#Attr.#arg_closure`;
    let `pf.Effect.109` : {} = Struct {};
    let `pf.Effect.108` : {} = CallByName `pf.Effect.effect_closure_stdoutLine` `pf.Effect.109` `pf.Effect.effect_map_thunk`;
    let `pf.Effect.107` : {} = CallByName `pf.Stdout.3` `pf.Effect.108`;
    ret `pf.Effect.107`;

procedure : `List.reserve` List [C , C , C , C U64, C U64, C , C , C ]
procedure = `List.reserve` (`#Attr.#arg1`: List [C , C , C , C U64, C U64, C , C , C ], `#Attr.#arg2`: U64):
    let `List.569` : List [C , C , C , C U64, C U64, C , C , C ] = lowlevel ListReserve `#Attr.#arg1` `#Attr.#arg2`;
    ret `List.569`;

procedure : `Num.add` U64
procedure = `Num.add` (`#Attr.#arg1`: U64, `#Attr.#arg2`: U64):
    let `Num.314` : U64 = lowlevel NumAdd `#Attr.#arg1` `#Attr.#arg2`;
    ret `Num.314`;

procedure : `List.dropLast` List U64
procedure = `List.dropLast` (`List.list`: List U64):
    let `List.641` : U64 = CallByName `List.len` `List.list`;
    let `List.642` : U64 = 1i64;
    let `List.639` : U64 = CallByName `Num.subSaturated` `List.641` `List.642`;
    let `List.638` : List U64 = CallByName `List.dropAt` `List.list` `List.639`;
    ret `List.638`;

procedure : `#UserApp.patchJump` [C , C , C , C U64, C U64, C , C , C ]
procedure = `#UserApp.patchJump` (`#UserApp.targetLocation`: U64, `#UserApp.op`: [C , C , C , C U64, C U64, C , C , C ]):
    let `#UserApp.272` : U8 = 4i64;
    let `#UserApp.273` : U8 = GetTagId `#UserApp.op`;
    let `#UserApp.274` : Int1 = lowlevel Eq `#UserApp.272` `#UserApp.273`;
    if `#UserApp.274` then
        let `#UserApp.269` : [C , C , C , C U64, C U64, C , C , C ] = TagId(4) `#UserApp.targetLocation`;
        ret `#UserApp.269`;
    else
        let `#UserApp.271` : Str = "Incorrect jump patch";
        Crash `#UserApp.271`

procedure : `pf..14` {}
procedure = `pf..14` (`pf..16`: {}, `#Attr.#arg_closure`: Str):
    let `pf..15` : {} = CallByName `pf.Effect.effect_closure_stdoutLine` `pf..16` `#Attr.#arg_closure`;
    ret `pf..15`;

procedure : `#UserApp.70` U8
procedure = `#UserApp.70` (`#UserApp.x`: U8):
    let `#UserApp.149` : U8 = 1i64;
    let `#UserApp.148` : U8 = CallByName `Num.add` `#UserApp.x` `#UserApp.149`;
    ret `#UserApp.148`;

procedure : `Str.concat` Str
procedure = `Str.concat` (`#Attr.#arg1`: Str, `#Attr.#arg2`: Str):
    let `Str.318` : Str = lowlevel StrConcat `#Attr.#arg1` `#Attr.#arg2`;
    ret `Str.318`;

procedure : `List.withCapacity` List U8
procedure = `List.withCapacity` (`#Attr.#arg1`: U64):
    let `List.619` : List U8 = lowlevel ListWithCapacity `#Attr.#arg1`;
    ret `List.619`;

procedure : `Num.subSaturated` U64
procedure = `Num.subSaturated` (`#Attr.#arg1`: U64, `#Attr.#arg2`: U64):
    let `Num.316` : U64 = lowlevel NumSubSaturated `#Attr.#arg1` `#Attr.#arg2`;
    ret `Num.316`;

procedure : `List.append` List U64
procedure = `List.append` (`List.list`: List U64, `List.element`: U64):
    let `List.588` : U64 = 1i64;
    let `List.586` : List U64 = CallByName `List.reserve` `List.list` `List.588`;
    let `List.585` : List U64 = CallByName `List.appendUnsafe` `List.586` `List.element`;
    ret `List.585`;

procedure : `pf.Effect.effect_closure_stdoutLine` {}
procedure = `pf.Effect.effect_closure_stdoutLine` (`pf.Effect.111`: {}, `pf.Effect.closure_arg_stdoutLine_0`: Str):
    let `pf.Effect.113` : {} = foreign "roc_fx_stdoutLine" `pf.Effect.closure_arg_stdoutLine_0`;
    dec `pf.Effect.closure_arg_stdoutLine_0`;
    ret `pf.Effect.113`;

procedure : `List.walk` {U64, List [C , C , C , C U64, C U64, C , C , C ], List U64}
procedure = `List.walk` (`List.list`: List U8, `List.state`: {U64, List [C , C , C , C U64, C U64, C , C , C ], List U64}, `List.func`: {}):
    let `List.620` : {U64, List [C , C , C , C U64, C U64, C , C , C ], List U64} = CallByName `List.iterate` `List.list` `List.state` `List.func`;
    ret `List.620`;

procedure : `#UserApp.initialState` {List U8, U64, List U8, List [C , C , C , C U64, C U64, C , C , C ], U64}
procedure = `#UserApp.initialState` (`#UserApp.program`: List [C , C , C , C U64, C U64, C , C , C ]):
    let `#UserApp.224` : U8 = 0i64;
    let `#UserApp.225` : U64 = CallByName `#UserApp.dataSize`;
    let `#UserApp.220` : List U8 = CallByName `List.repeat` `#UserApp.224` `#UserApp.225`;
    let `#UserApp.221` : U64 = 0i64;
    let `#UserApp.222` : List U8 = Array [];
    let `#UserApp.223` : U64 = 0i64;
    let `#UserApp.219` : {List U8, U64, List U8, List [C , C , C , C U64, C U64, C , C , C ], U64} = Struct {`#UserApp.220`, `#UserApp.221`, `#UserApp.222`, `#UserApp.program`, `#UserApp.223`};
    ret `#UserApp.219`;

procedure : `List.len` U64
procedure = `List.len` (`#Attr.#arg1`: List [C , C , C , C U64, C U64, C , C , C ]):
    let `List.608` : U64 = lowlevel ListLen `#Attr.#arg1`;
    ret `List.608`;

procedure : `List.repeatHelp` List U8
procedure = `List.repeatHelp` (`Bool.IdentId(30)`: U8, `Bool.IdentId(31)`: U64, `Bool.IdentId(32)`: List U8):
    joinpoint `List.611` `List.value` `List.count` `List.accum`:
        let `List.618` : U64 = 0i64;
        let `List.613` : Int1 = CallByName `Num.isGt` `List.count` `List.618`;
        if `List.613` then
            let `List.617` : U64 = 1i64;
            let `List.615` : U64 = CallByName `Num.sub` `List.count` `List.617`;
            let `List.616` : List U8 = CallByName `List.appendUnsafe` `List.accum` `List.value`;
            jump `List.611` `List.value` `List.615` `List.616`;
        else
            ret `List.accum`;
    in
    jump `List.611` `Bool.IdentId(30)` `Bool.IdentId(31)` `Bool.IdentId(32)`;

procedure : `List.dropAt` List U64
procedure = `List.dropAt` (`#Attr.#arg1`: List U64, `#Attr.#arg2`: U64):
    let `List.640` : List U64 = lowlevel ListDropAt `#Attr.#arg1` `#Attr.#arg2`;
    ret `List.640`;

procedure : `Num.sub` U8
procedure = `Num.sub` (`#Attr.#arg1`: U8, `#Attr.#arg2`: U8):
    let `Num.304` : U8 = lowlevel NumSub `#Attr.#arg1` `#Attr.#arg2`;
    ret `Num.304`;

procedure : `List.replaceUnsafe` {List [C , C , C , C U64, C U64, C , C , C ], [C , C , C , C U64, C U64, C , C , C ]}
procedure = `List.replaceUnsafe` (`#Attr.#arg1`: List [C , C , C , C U64, C U64, C , C , C ], `#Attr.#arg2`: U64, `#Attr.#arg3`: [C , C , C , C U64, C U64, C , C , C ]):
    let `List.548` : {List [C , C , C , C U64, C U64, C , C , C ], [C , C , C , C U64, C U64, C , C , C ]} = lowlevel ListReplaceUnsafe `#Attr.#arg1` `#Attr.#arg2` `#Attr.#arg3`;
    ret `List.548`;

procedure : `List.replaceUnsafe` {List U8, U8}
procedure = `List.replaceUnsafe` (`#Attr.#arg1`: List U8, `#Attr.#arg2`: U64, `#Attr.#arg3`: U8):
    let `List.525` : {List U8, U8} = lowlevel ListReplaceUnsafe `#Attr.#arg1` `#Attr.#arg2` `#Attr.#arg3`;
    ret `List.525`;

procedure : `List.get` [C {}, C [C , C , C , C U64, C U64, C , C , C ]]
procedure = `List.get` (`List.list`: List [C , C , C , C U64, C U64, C , C , C ], `List.index`: U64):
    let `List.607` : U64 = CallByName `List.len` `List.list`;
    let `List.604` : Int1 = CallByName `Num.isLt` `List.index` `List.607`;
    if `List.604` then
        let `List.606` : [C , C , C , C U64, C U64, C , C , C ] = CallByName `List.getUnsafe` `List.list` `List.index`;
        dec `List.list`;
        let `List.605` : [C {}, C [C , C , C , C U64, C U64, C , C , C ]] = TagId(1) `List.606`;
        ret `List.605`;
    else
        dec `List.list`;
        let `List.603` : {} = Struct {};
        let `List.602` : [C {}, C [C , C , C , C U64, C U64, C , C , C ]] = TagId(0) `List.603`;
        ret `List.602`;

procedure : `Num.isLt` Int1
procedure = `Num.isLt` (`#Attr.#arg1`: U64, `#Attr.#arg2`: U64):
    let `Num.311` : Int1 = lowlevel NumLt `#Attr.#arg1` `#Attr.#arg2`;
    ret `Num.311`;

procedure : `List.len` U64
procedure = `List.len` (`#Attr.#arg1`: List U64):
    let `List.643` : U64 = lowlevel ListLen `#Attr.#arg1`;
    ret `List.643`;

procedure : `Str.toUtf8` List U8
procedure = `Str.toUtf8` (`#Attr.#arg1`: Str):
    let `Str.319` : List U8 = lowlevel StrToUtf8 `#Attr.#arg1`;
    ret `Str.319`;

procedure : `#UserApp.dataSize` U64
procedure = `#UserApp.dataSize` ():
    let `#UserApp.226` : U64 = 1000i64;
    ret `#UserApp.226`;

procedure : `Str.fromUtf8RangeLowlevel` {U64, Str, Int1, U8}
procedure = `Str.fromUtf8RangeLowlevel` (`#Attr.#arg1`: List U8, `#Attr.#arg2`: U64, `#Attr.#arg3`: U64):
    let `Str.307` : {U64, Str, Int1, U8} = lowlevel StrFromUtf8Range `#Attr.#arg1` `#Attr.#arg2` `#Attr.#arg3`;
    ret `Str.307`;

procedure : `Num.sub` U64
procedure = `Num.sub` (`#Attr.#arg1`: U64, `#Attr.#arg2`: U64):
    let `Num.312` : U64 = lowlevel NumSub `#Attr.#arg1` `#Attr.#arg2`;
    ret `Num.312`;

procedure : `pf.Stdout.line` {Str, {}}
procedure = `pf.Stdout.line` (`pf.Stdout.str`: Str):
    let `pf.Stdout.10` : Str = CallByName `pf.Effect.stdoutLine` `pf.Stdout.str`;
    let `pf.Stdout.11` : {} = Struct {};
    let `pf.Stdout.9` : {Str, {}} = CallByName `pf.Effect.map` `pf.Stdout.10` `pf.Stdout.11`;
    let `pf.Stdout.8` : {Str, {}} = CallByName `pf.InternalTask.fromEffect` `pf.Stdout.9`;
    ret `pf.Stdout.8`;

procedure : `#UserApp.tokenizeOne` {U64, List [C , C , C , C U64, C U64, C , C , C ], List U64}
procedure = `#UserApp.tokenizeOne` (`#UserApp.95`: {U64, List [C , C , C , C U64, C U64, C , C , C ], List U64}, `#UserApp.char`: U8):
    let `#UserApp.pc` : U64 = StructAtIndex 0 `#UserApp.95`;
    let `#UserApp.instructions` : List [C , C , C , C U64, C U64, C , C , C ] = StructAtIndex 1 `#UserApp.95`;
    let `#UserApp.jumpStack` : List U64 = StructAtIndex 2 `#UserApp.95`;
    switch `#UserApp.char`:
        case 62:
            let `#UserApp.233` : [C , C , C , C U64, C U64, C , C , C ] = TagId(5) ;
            let `#UserApp.instructions2` : List [C , C , C , C U64, C U64, C , C , C ] = CallByName `List.append` `#UserApp.instructions` `#UserApp.233`;
            let `#UserApp.232` : U64 = 1i64;
            let `#UserApp.231` : U64 = CallByName `Num.add` `#UserApp.pc` `#UserApp.232`;
            let `#UserApp.230` : {U64, List [C , C , C , C U64, C U64, C , C , C ], List U64} = Struct {`#UserApp.231`, `#UserApp.instructions2`, `#UserApp.jumpStack`};
            ret `#UserApp.230`;

        case 60:
            let `#UserApp.237` : [C , C , C , C U64, C U64, C , C , C ] = TagId(7) ;
            let `#UserApp.instructions2` : List [C , C , C , C U64, C U64, C , C , C ] = CallByName `List.append` `#UserApp.instructions` `#UserApp.237`;
            let `#UserApp.236` : U64 = 1i64;
            let `#UserApp.235` : U64 = CallByName `Num.add` `#UserApp.pc` `#UserApp.236`;
            let `#UserApp.234` : {U64, List [C , C , C , C U64, C U64, C , C , C ], List U64} = Struct {`#UserApp.235`, `#UserApp.instructions2`, `#UserApp.jumpStack`};
            ret `#UserApp.234`;

        case 43:
            let `#UserApp.241` : [C , C , C , C U64, C U64, C , C , C ] = TagId(1) ;
            let `#UserApp.instructions2` : List [C , C , C , C U64, C U64, C , C , C ] = CallByName `List.append` `#UserApp.instructions` `#UserApp.241`;
            let `#UserApp.240` : U64 = 1i64;
            let `#UserApp.239` : U64 = CallByName `Num.add` `#UserApp.pc` `#UserApp.240`;
            let `#UserApp.238` : {U64, List [C , C , C , C U64, C U64, C , C , C ], List U64} = Struct {`#UserApp.239`, `#UserApp.instructions2`, `#UserApp.jumpStack`};
            ret `#UserApp.238`;

        case 45:
            let `#UserApp.245` : [C , C , C , C U64, C U64, C , C , C ] = TagId(0) ;
            let `#UserApp.instructions2` : List [C , C , C , C U64, C U64, C , C , C ] = CallByName `List.append` `#UserApp.instructions` `#UserApp.245`;
            let `#UserApp.244` : U64 = 1i64;
            let `#UserApp.243` : U64 = CallByName `Num.add` `#UserApp.pc` `#UserApp.244`;
            let `#UserApp.242` : {U64, List [C , C , C , C U64, C U64, C , C , C ], List U64} = Struct {`#UserApp.243`, `#UserApp.instructions2`, `#UserApp.jumpStack`};
            ret `#UserApp.242`;

        case 46:
            let `#UserApp.249` : [C , C , C , C U64, C U64, C , C , C ] = TagId(6) ;
            let `#UserApp.instructions2` : List [C , C , C , C U64, C U64, C , C , C ] = CallByName `List.append` `#UserApp.instructions` `#UserApp.249`;
            let `#UserApp.248` : U64 = 1i64;
            let `#UserApp.247` : U64 = CallByName `Num.add` `#UserApp.pc` `#UserApp.248`;
            let `#UserApp.246` : {U64, List [C , C , C , C U64, C U64, C , C , C ], List U64} = Struct {`#UserApp.247`, `#UserApp.instructions2`, `#UserApp.jumpStack`};
            ret `#UserApp.246`;

        case 44:
            let `#UserApp.253` : [C , C , C , C U64, C U64, C , C , C ] = TagId(2) ;
            let `#UserApp.instructions2` : List [C , C , C , C U64, C U64, C , C , C ] = CallByName `List.append` `#UserApp.instructions` `#UserApp.253`;
            let `#UserApp.252` : U64 = 1i64;
            let `#UserApp.251` : U64 = CallByName `Num.add` `#UserApp.pc` `#UserApp.252`;
            let `#UserApp.250` : {U64, List [C , C , C , C U64, C U64, C , C , C ], List U64} = Struct {`#UserApp.251`, `#UserApp.instructions2`, `#UserApp.jumpStack`};
            ret `#UserApp.250`;

        case 91:
            let `#UserApp.258` : U64 = 0i64;
            let `#UserApp.257` : [C , C , C , C U64, C U64, C , C , C ] = TagId(4) `#UserApp.258`;
            let `#UserApp.instructions2` : List [C , C , C , C U64, C U64, C , C , C ] = CallByName `List.append` `#UserApp.instructions` `#UserApp.257`;
            let `#UserApp.jumpStack2` : List U64 = CallByName `List.append` `#UserApp.jumpStack` `#UserApp.pc`;
            let `#UserApp.256` : U64 = 1i64;
            let `#UserApp.255` : U64 = CallByName `Num.add` `#UserApp.pc` `#UserApp.256`;
            let `#UserApp.254` : {U64, List [C , C , C , C U64, C U64, C , C , C ], List U64} = Struct {`#UserApp.255`, `#UserApp.instructions2`, `#UserApp.jumpStack2`};
            ret `#UserApp.254`;

        case 93:
            let `#UserApp.259` : [C {}, C {U64, List U64}] = CallByName `#UserApp.pop` `#UserApp.jumpStack`;
            let `#UserApp.277` : U8 = 0i64;
            let `#UserApp.278` : U8 = GetTagId `#UserApp.259`;
            let `#UserApp.279` : Int1 = lowlevel Eq `#UserApp.277` `#UserApp.278`;
            if `#UserApp.279` then
                dec `#UserApp.instructions`;
                dec `#UserApp.259`;
                let `#UserApp.261` : Str = "Malformed BF program";
                Crash `#UserApp.261`
            else
                let `#UserApp.276` : {U64, List U64} = UnionAtIndex (Id 1) (Index 0) `#UserApp.259`;
                let `#UserApp.location` : U64 = StructAtIndex 0 `#UserApp.276`;
                let `#UserApp.jumpStack2` : List U64 = StructAtIndex 1 `#UserApp.276`;
                let `#UserApp.275` : [C , C , C , C U64, C U64, C , C , C ] = TagId(3) `#UserApp.location`;
                let `#UserApp.265` : List [C , C , C , C U64, C U64, C , C , C ] = CallByName `List.append` `#UserApp.instructions` `#UserApp.275`;
                let `#UserApp.instructions2` : List [C , C , C , C U64, C U64, C , C , C ] = CallByName `List.update` `#UserApp.265` `#UserApp.location` `#UserApp.pc`;
                let `#UserApp.264` : U64 = 1i64;
                let `#UserApp.263` : U64 = CallByName `Num.add` `#UserApp.pc` `#UserApp.264`;
                let `#UserApp.262` : {U64, List [C , C , C , C U64, C U64, C , C , C ], List U64} = Struct {`#UserApp.263`, `#UserApp.instructions2`, `#UserApp.jumpStack2`};
                ret `#UserApp.262`;

        case 32:
            let `#UserApp.287` : {U64, List [C , C , C , C U64, C U64, C , C , C ], List U64} = Struct {`#UserApp.pc`, `#UserApp.instructions`, `#UserApp.jumpStack`};
            ret `#UserApp.287`;

        case 10:
            let `#UserApp.288` : {U64, List [C , C , C , C U64, C U64, C , C , C ], List U64} = Struct {`#UserApp.pc`, `#UserApp.instructions`, `#UserApp.jumpStack`};
            ret `#UserApp.288`;

        case 9:
            let `#UserApp.289` : {U64, List [C , C , C , C U64, C U64, C , C , C ], List U64} = Struct {`#UserApp.pc`, `#UserApp.instructions`, `#UserApp.jumpStack`};
            ret `#UserApp.289`;

        default:
            dec `#UserApp.instructions`;
            dec `#UserApp.jumpStack`;
            let `#UserApp.301` : List U8 = Array [`#UserApp.char`];
            let `#UserApp.290` : [C {U64, U8}, C Str] = CallByName `Str.fromUtf8` `#UserApp.301`;
            let `#UserApp.298` : U8 = 1i64;
            let `#UserApp.299` : U8 = GetTagId `#UserApp.290`;
            let `#UserApp.300` : Int1 = lowlevel Eq `#UserApp.298` `#UserApp.299`;
            if `#UserApp.300` then
                let `#UserApp.str` : Str = UnionAtIndex (Id 1) (Index 0) `#UserApp.290`;
                let `#UserApp.293` : Str = "unexpected character: '";
                let `#UserApp.295` : Str = "'";
                let `#UserApp.294` : Str = CallByName `Str.concat` `#UserApp.str` `#UserApp.295`;
                dec `#UserApp.295`;
                let `#UserApp.292` : Str = CallByName `Str.concat` `#UserApp.293` `#UserApp.294`;
                dec `#UserApp.294`;
                Crash `#UserApp.292`
            else
                dec `#UserApp.290`;
                let `#UserApp.297` : Str = "unexpected non-utf8 character";
                Crash `#UserApp.297`


procedure : `List.getUnsafe` U64
procedure = `List.getUnsafe` (`#Attr.#arg1`: List U64, `#Attr.#arg2`: U64):
    let `List.657` : U64 = lowlevel ListGetUnsafe `#Attr.#arg1` `#Attr.#arg2`;
    ret `List.657`;

procedure : `Num.isGt` Int1
procedure = `Num.isGt` (`#Attr.#arg1`: U64, `#Attr.#arg2`: U64):
    let `Num.313` : Int1 = lowlevel NumGt `#Attr.#arg1` `#Attr.#arg2`;
    ret `Num.313`;

procedure : `Num.add` U8
procedure = `Num.add` (`#Attr.#arg1`: U8, `#Attr.#arg2`: U8):
    let `Num.294` : U8 = lowlevel NumAdd `#Attr.#arg1` `#Attr.#arg2`;
    ret `Num.294`;

procedure : `List.iterate` {U64, List [C , C , C , C U64, C U64, C , C , C ], List U64}
procedure = `List.iterate` (`List.list`: List U8, `List.init`: {U64, List [C , C , C , C U64, C U64, C , C , C ], List U64}, `List.func`: {}):
    let `List.624` : U64 = 0i64;
    let `List.625` : U64 = CallByName `List.len` `List.list`;
    let `List.623` : {U64, List [C , C , C , C U64, C U64, C , C , C ], List U64} = CallByName `List.iterHelp` `List.list` `List.init` `List.func` `List.624` `List.625`;
    ret `List.623`;

procedure : `Bool.structuralEq` Int1
procedure = `Bool.structuralEq` (`#Attr.#arg1`: U8, `#Attr.#arg2`: U8):
    let `Bool.23` : Int1 = lowlevel Eq `#Attr.#arg1` `#Attr.#arg2`;
    ret `Bool.23`;

procedure : `#UserApp.runOne` [C {List U8, U64, List U8, List [C , C , C , C U64, C U64, C , C , C ], U64}, C {List U8, U64, List U8, List [C , C , C , C U64, C U64, C , C , C ], U64}]
procedure = `#UserApp.runOne` (`#UserApp.state`: {List U8, U64, List U8, List [C , C , C , C U64, C U64, C , C , C ], U64}):
    let `#UserApp.216` : U64 = StructAtIndex 4 `#UserApp.state`;
    let `#UserApp.218` : List [C , C , C , C U64, C U64, C , C , C ] = StructAtIndex 3 `#UserApp.state`;
    let `#UserApp.217` : U64 = CallByName `List.len` `#UserApp.218`;
    let `#UserApp.213` : Int1 = CallByName `Num.isGte` `#UserApp.216` `#UserApp.217`;
    if `#UserApp.213` then
        let `#UserApp.214` : [C {List U8, U64, List U8, List [C , C , C , C U64, C U64, C , C , C ], U64}, C {List U8, U64, List U8, List [C , C , C , C U64, C U64, C , C , C ], U64}] = TagId(0) `#UserApp.state`;
        ret `#UserApp.214`;
    else
        let `#UserApp.204` : List [C , C , C , C U64, C U64, C , C , C ] = StructAtIndex 3 `#UserApp.state`;
        inc `#UserApp.204`;
        let `#UserApp.205` : U64 = StructAtIndex 4 `#UserApp.state`;
        let `#UserApp.op` : [C , C , C , C U64, C U64, C , C , C ] = CallByName `#UserApp.getUnsafe` `#UserApp.204` `#UserApp.205`;
        joinpoint `#UserApp.122` `#UserApp.state2`:
            let `#UserApp.121` : [C {List U8, U64, List U8, List [C , C , C , C U64, C U64, C , C , C ], U64}, C {List U8, U64, List U8, List [C , C , C , C U64, C U64, C , C , C ], U64}] = TagId(1) `#UserApp.state2`;
            ret `#UserApp.121`;
        in
        let `#UserApp.203` : U8 = GetTagId `#UserApp.op`;
        switch `#UserApp.203`:
            case 5:
                let `#UserApp.124` : List U8 = StructAtIndex 0 `#UserApp.state`;
                let `#UserApp.125` : U64 = StructAtIndex 1 `#UserApp.state`;
                let `#UserApp.127` : List U8 = StructAtIndex 2 `#UserApp.state`;
                let `#UserApp.128` : List [C , C , C , C U64, C U64, C , C , C ] = StructAtIndex 3 `#UserApp.state`;
                let `#UserApp.129` : U64 = StructAtIndex 4 `#UserApp.state`;
                let `#UserApp.130` : U64 = 1i64;
                let `#UserApp.126` : U64 = CallByName `Num.add` `#UserApp.125` `#UserApp.130`;
                let `#UserApp.123` : {List U8, U64, List U8, List [C , C , C , C U64, C U64, C , C , C ], U64} = Struct {`#UserApp.124`, `#UserApp.126`, `#UserApp.127`, `#UserApp.128`, `#UserApp.129`};
                jump `#UserApp.122` `#UserApp.123`;

            case 7:
                let `#UserApp.132` : List U8 = StructAtIndex 0 `#UserApp.state`;
                let `#UserApp.133` : U64 = StructAtIndex 1 `#UserApp.state`;
                let `#UserApp.135` : List U8 = StructAtIndex 2 `#UserApp.state`;
                let `#UserApp.136` : List [C , C , C , C U64, C U64, C , C , C ] = StructAtIndex 3 `#UserApp.state`;
                let `#UserApp.137` : U64 = StructAtIndex 4 `#UserApp.state`;
                let `#UserApp.138` : U64 = 1i64;
                let `#UserApp.134` : U64 = CallByName `Num.sub` `#UserApp.133` `#UserApp.138`;
                let `#UserApp.131` : {List U8, U64, List U8, List [C , C , C , C U64, C U64, C , C , C ], U64} = Struct {`#UserApp.132`, `#UserApp.134`, `#UserApp.135`, `#UserApp.136`, `#UserApp.137`};
                jump `#UserApp.122` `#UserApp.131`;

            case 1:
                let `#UserApp.145` : List U8 = StructAtIndex 0 `#UserApp.state`;
                inc `#UserApp.145`;
                let `#UserApp.146` : U64 = StructAtIndex 1 `#UserApp.state`;
                let `#UserApp.147` : {} = Struct {};
                let `#UserApp.data` : List U8 = CallByName `List.update` `#UserApp.145` `#UserApp.146` `#UserApp.147`;
                let `#UserApp.141` : U64 = StructAtIndex 1 `#UserApp.state`;
                let `#UserApp.142` : List U8 = StructAtIndex 2 `#UserApp.state`;
                let `#UserApp.143` : List [C , C , C , C U64, C U64, C , C , C ] = StructAtIndex 3 `#UserApp.state`;
                let `#UserApp.144` : U64 = StructAtIndex 4 `#UserApp.state`;
                dec `#UserApp.145`;
                let `#UserApp.139` : {List U8, U64, List U8, List [C , C , C , C U64, C U64, C , C , C ], U64} = Struct {`#UserApp.data`, `#UserApp.141`, `#UserApp.142`, `#UserApp.143`, `#UserApp.144`};
                jump `#UserApp.122` `#UserApp.139`;

            case 0:
                let `#UserApp.156` : List U8 = StructAtIndex 0 `#UserApp.state`;
                inc `#UserApp.156`;
                let `#UserApp.157` : U64 = StructAtIndex 1 `#UserApp.state`;
                let `#UserApp.158` : {} = Struct {};
                let `#UserApp.data` : List U8 = CallByName `List.update` `#UserApp.156` `#UserApp.157` `#UserApp.158`;
                let `#UserApp.152` : U64 = StructAtIndex 1 `#UserApp.state`;
                let `#UserApp.153` : List U8 = StructAtIndex 2 `#UserApp.state`;
                let `#UserApp.154` : List [C , C , C , C U64, C U64, C , C , C ] = StructAtIndex 3 `#UserApp.state`;
                let `#UserApp.155` : U64 = StructAtIndex 4 `#UserApp.state`;
                dec `#UserApp.156`;
                let `#UserApp.150` : {List U8, U64, List U8, List [C , C , C , C U64, C U64, C , C , C ], U64} = Struct {`#UserApp.data`, `#UserApp.152`, `#UserApp.153`, `#UserApp.154`, `#UserApp.155`};
                jump `#UserApp.122` `#UserApp.150`;

            case 2:
                let `Bool.IdentId(45)` : List U8 = StructAtIndex 0 `#UserApp.state`;
                dec `Bool.IdentId(45)`;
                let `Bool.IdentId(44)` : List U8 = StructAtIndex 2 `#UserApp.state`;
                dec `Bool.IdentId(44)`;
                dec `#UserApp.204`;
                let `#UserApp.162` : Str = "Input (,) is not implemented yet";
                Crash `#UserApp.162`

            case 6:
                let `#UserApp.170` : List U8 = StructAtIndex 0 `#UserApp.state`;
                inc `#UserApp.170`;
                let `#UserApp.171` : U64 = StructAtIndex 1 `#UserApp.state`;
                let `#UserApp.val` : U8 = CallByName `#UserApp.getUnsafe` `#UserApp.170` `#UserApp.171`;
                let `#UserApp.169` : List U8 = StructAtIndex 2 `#UserApp.state`;
                inc `#UserApp.169`;
                let `#UserApp.output2` : List U8 = CallByName `List.append` `#UserApp.169` `#UserApp.val`;
                let `#UserApp.164` : List U8 = StructAtIndex 0 `#UserApp.state`;
                let `#UserApp.165` : U64 = StructAtIndex 1 `#UserApp.state`;
                let `#UserApp.167` : List [C , C , C , C U64, C U64, C , C , C ] = StructAtIndex 3 `#UserApp.state`;
                let `#UserApp.168` : U64 = StructAtIndex 4 `#UserApp.state`;
                dec `#UserApp.169`;
                let `#UserApp.163` : {List U8, U64, List U8, List [C , C , C , C U64, C U64, C , C , C ], U64} = Struct {`#UserApp.164`, `#UserApp.165`, `#UserApp.output2`, `#UserApp.167`, `#UserApp.168`};
                jump `#UserApp.122` `#UserApp.163`;

            case 4:
                let `#UserApp.targetLocation` : U64 = UnionAtIndex (Id 4) (Index 0) `#UserApp.op`;
                let `#UserApp.189` : List U8 = StructAtIndex 0 `#UserApp.state`;
                inc `#UserApp.189`;
                let `#UserApp.190` : U64 = StructAtIndex 1 `#UserApp.state`;
                let `#UserApp.val` : U8 = CallByName `#UserApp.getUnsafe` `#UserApp.189` `#UserApp.190`;
                joinpoint `#UserApp.181` `#UserApp.179`:
                    jump `#UserApp.122` `#UserApp.179`;
                in
                let `#UserApp.188` : U8 = 0i64;
                let `#UserApp.182` : Int1 = CallByName `Bool.structuralEq` `#UserApp.val` `#UserApp.188`;
                if `#UserApp.182` then
                    let `#UserApp.183` : List U8 = StructAtIndex 0 `#UserApp.state`;
                    let `#UserApp.184` : U64 = StructAtIndex 1 `#UserApp.state`;
                    let `#UserApp.185` : List U8 = StructAtIndex 2 `#UserApp.state`;
                    let `#UserApp.186` : List [C , C , C , C U64, C U64, C , C , C ] = StructAtIndex 3 `#UserApp.state`;
                    let `#UserApp.180` : {List U8, U64, List U8, List [C , C , C , C U64, C U64, C , C , C ], U64} = Struct {`#UserApp.183`, `#UserApp.184`, `#UserApp.185`, `#UserApp.186`, `#UserApp.targetLocation`};
                    jump `#UserApp.181` `#UserApp.180`;
                else
                    jump `#UserApp.181` `#UserApp.state`;

            default:
                let `#UserApp.targetLocation` : U64 = UnionAtIndex (Id 3) (Index 0) `#UserApp.op`;
                let `#UserApp.201` : List U8 = StructAtIndex 0 `#UserApp.state`;
                inc `#UserApp.201`;
                let `#UserApp.202` : U64 = StructAtIndex 1 `#UserApp.state`;
                let `#UserApp.val` : U8 = CallByName `#UserApp.getUnsafe` `#UserApp.201` `#UserApp.202`;
                joinpoint `#UserApp.193` `#UserApp.191`:
                    jump `#UserApp.122` `#UserApp.191`;
                in
                let `#UserApp.200` : U8 = 0i64;
                let `#UserApp.194` : Int1 = CallByName `Bool.isNotEq` `#UserApp.val` `#UserApp.200`;
                if `#UserApp.194` then
                    let `#UserApp.195` : List U8 = StructAtIndex 0 `#UserApp.state`;
                    let `#UserApp.196` : U64 = StructAtIndex 1 `#UserApp.state`;
                    let `#UserApp.197` : List U8 = StructAtIndex 2 `#UserApp.state`;
                    let `#UserApp.198` : List [C , C , C , C U64, C U64, C , C , C ] = StructAtIndex 3 `#UserApp.state`;
                    let `#UserApp.192` : {List U8, U64, List U8, List [C , C , C , C U64, C U64, C , C , C ], U64} = Struct {`#UserApp.195`, `#UserApp.196`, `#UserApp.197`, `#UserApp.198`, `#UserApp.targetLocation`};
                    jump `#UserApp.193` `#UserApp.192`;
                else
                    jump `#UserApp.193` `#UserApp.state`;


procedure : `pf..roc__getter__0` Str
procedure = `pf..roc__getter__0` (`pf..4`: [<rnnu>C {Str, {}}]):
    let `pf..5` : {Str, {}} = UnionAtIndex (Id 0) (Index 0) `pf..4`;
    inc `pf..5`;
    dec `pf..4`;
    let `pf..6` : Str = StructAtIndex 0 `pf..5`;
    ret `pf..6`;

procedure : `List.len` U64
procedure = `List.len` (`#Attr.#arg1`: List U8):
    let `List.662` : U64 = lowlevel ListLen `#Attr.#arg1`;
    ret `List.662`;

procedure : `List.iterHelp` {U64, List [C , C , C , C U64, C U64, C , C , C ], List U64}
procedure = `List.iterHelp` (`Bool.IdentId(33)`: List U8, `Bool.IdentId(34)`: {U64, List [C , C , C , C U64, C U64, C , C , C ], List U64}, `Bool.IdentId(35)`: {}, `Bool.IdentId(36)`:
U64, `Bool.IdentId(37)`: U64):
    joinpoint `List.626` `List.list` `List.state` `List.f` `List.index` `List.length`:
        let `List.628` : Int1 = CallByName `Num.isLt` `List.index` `List.length`;
        if `List.628` then
            let `List.635` : U8 = CallByName `List.getUnsafe` `List.list` `List.index`;
            let `List.629` : {U64, List [C , C , C , C U64, C U64, C , C , C ], List U64} = CallByName `List.walkHelp` `List.state` `List.635` `List.f`;
            let `List.632` : U64 = 1i64;
            let `List.631` : U64 = CallByName `Num.add` `List.index` `List.632`;
            jump `List.626` `List.list` `List.629` `List.f` `List.631` `List.length`;
        else
            dec `List.list`;
            ret `List.state`;
    in
    jump `List.626` `Bool.IdentId(33)` `Bool.IdentId(34)` `Bool.IdentId(35)` `Bool.IdentId(36)` `Bool.IdentId(37)`;

procedure : `#UserApp.getUnsafe` U8
procedure = `#UserApp.getUnsafe` (`#UserApp.list`: List U8, `#UserApp.index`: U64):
    let `#UserApp.172` : [C {}, C U8] = CallByName `List.get` `#UserApp.list` `#UserApp.index`;
    let `#UserApp.176` : U8 = 0i64;
    let `#UserApp.177` : U8 = GetTagId `#UserApp.172`;
    let `#UserApp.178` : Int1 = lowlevel Eq `#UserApp.176` `#UserApp.177`;
    if `#UserApp.178` then
        let `#UserApp.174` : Str = "Out of bounds";
        Crash `#UserApp.174`
    else
        let `#UserApp.val` : U8 = UnionAtIndex (Id 1) (Index 0) `#UserApp.172`;
        ret `#UserApp.val`;

procedure : `pf.InternalTask.fromEffect` {Str, {}}
procedure = `pf.InternalTask.fromEffect` (`pf.InternalTask.effect`: {Str, {}}):
    ret `pf.InternalTask.effect`;

procedure : `List.append` List U8
procedure = `List.append` (`List.list`: List U8, `List.element`: U8):
    let `List.563` : U64 = 1i64;
    let `List.561` : List U8 = CallByName `List.reserve` `List.list` `List.563`;
    let `List.560` : List U8 = CallByName `List.appendUnsafe` `List.561` `List.element`;
    ret `List.560`;

procedure : `List.last` [C {}, C U64]
procedure = `List.last` (`List.list`: List U64):
    let `List.659` : U64 = CallByName `List.len` `List.list`;
    let `List.660` : U64 = 1i64;
    let `List.651` : U64 = CallByName `Num.subSaturated` `List.659` `List.660`;
    let `List.644` : [C {}, C U64] = CallByName `List.get` `List.list` `List.651`;
    let `List.648` : U8 = 1i64;
    let `List.649` : U8 = GetTagId `List.644`;
    let `List.650` : Int1 = lowlevel Eq `List.648` `List.649`;
    if `List.650` then
        let `List.v` : U64 = UnionAtIndex (Id 1) (Index 0) `List.644`;
        let `List.645` : [C {}, C U64] = TagId(1) `List.v`;
        ret `List.645`;
    else
        let `List.647` : {} = Struct {};
        let `List.646` : [C {}, C U64] = TagId(0) `List.647`;
        ret `List.646`;

procedure : `Bool.isNotEq` Int1
procedure = `Bool.isNotEq` (`Bool.a`: U8, `Bool.b`: U8):
    let `Bool.24` : Int1 = CallByName `Bool.structuralNotEq` `Bool.a` `Bool.b`;
    ret `Bool.24`;

procedure : `#UserApp.main` {Str, {}}
procedure = `#UserApp.main` ():
    let `#UserApp.305` : Str = CallByName `#UserApp.print0to999`;
    let `#UserApp.sourceCode` : List U8 = CallByName `Str.toUtf8` `#UserApp.305`;
    let `#UserApp.program` : List [C , C , C , C U64, C U64, C , C , C ] = CallByName `#UserApp.tokenize` `#UserApp.sourceCode`;
    let `#UserApp.state` : {List U8, U64, List U8, List [C , C , C , C U64, C U64, C , C , C ], U64} = CallByName `#UserApp.initialState` `#UserApp.program`;
    let `#UserApp.outputBytes` : List U8 = CallByName `#UserApp.run` `#UserApp.state`;
    joinpoint `#UserApp.98` `#UserApp.outputStr`:
        let `#UserApp.96` : {Str, {}} = CallByName `pf.Stdout.line` `#UserApp.outputStr`;
        ret `#UserApp.96`;
    in
    let `#UserApp.97` : [C {U64, U8}, C Str] = CallByName `Str.fromUtf8` `#UserApp.outputBytes`;
    let `#UserApp.102` : U8 = 0i64;
    let `#UserApp.103` : U8 = GetTagId `#UserApp.97`;
    let `#UserApp.104` : Int1 = lowlevel Eq `#UserApp.102` `#UserApp.103`;
    if `#UserApp.104` then
        dec `#UserApp.97`;
        let `#UserApp.100` : Str = "invalid utf8 in the output";
        Crash `#UserApp.100`
    else
        let `#UserApp.str` : Str = UnionAtIndex (Id 1) (Index 0) `#UserApp.97`;
        jump `#UserApp.98` `#UserApp.str`;

procedure : `#UserApp.run` List U8
procedure = `#UserApp.run` (`Bool.IdentId(38)`: {List U8, U64, List U8, List [C , C , C , C U64, C U64, C , C , C ], U64}):
    joinpoint `#UserApp.105` `#UserApp.state`:
        let `#UserApp.106` : [C {List U8, U64, List U8, List [C , C , C , C U64, C U64, C , C , C ], U64}, C {List U8, U64, List U8, List [C , C , C , C U64, C U64, C , C , C ], U64}] = CallByName `#UserApp.runOne` `#UserApp.state`;
        let `#UserApp.118` : U8 = 1i64;
        let `#UserApp.119` : U8 = GetTagId `#UserApp.106`;
        let `#UserApp.120` : Int1 = lowlevel Eq `#UserApp.118` `#UserApp.119`;
        if `#UserApp.120` then
            let `#UserApp.state2` : {List U8, U64, List U8, List [C , C , C , C U64, C U64, C , C , C ], U64} = UnionAtIndex (Id 1) (Index 0) `#UserApp.106`;
            let `#UserApp.114` : U64 = StructAtIndex 4 `#UserApp.state2`;
            let `#UserApp.115` : U64 = 1i64;
            let `#UserApp.programCounter` : U64 = CallByName `Num.add` `#UserApp.114` `#UserApp.115`;
            let `#UserApp.109` : List U8 = StructAtIndex 0 `#UserApp.state2`;
            let `#UserApp.110` : U64 = StructAtIndex 1 `#UserApp.state2`;
            let `#UserApp.111` : List U8 = StructAtIndex 2 `#UserApp.state2`;
            let `#UserApp.112` : List [C , C , C , C U64, C U64, C , C , C ] = StructAtIndex 3 `#UserApp.state2`;
            let `#UserApp.108` : {List U8, U64, List U8, List [C , C , C , C U64, C U64, C , C , C ], U64} = Struct {`#UserApp.109`, `#UserApp.110`, `#UserApp.111`, `#UserApp.112`, `#UserApp.programCounter`};
            jump `#UserApp.105` `#UserApp.108`;
        else
            let `#UserApp.117` : {List U8, U64, List U8, List [C , C , C , C U64, C U64, C , C , C ], U64} = UnionAtIndex (Id 0) (Index 0) `#UserApp.106`;
            let `#UserApp.116` : List U8 = StructAtIndex 2 `#UserApp.117`;
            let `Bool.IdentId(47)` : List U8 = StructAtIndex 0 `#UserApp.117`;
            dec `Bool.IdentId(47)`;
            let `Bool.IdentId(46)` : List [C , C , C , C U64, C U64, C , C , C ] = StructAtIndex 3 `#UserApp.117`;
            dec `Bool.IdentId(46)`;
            ret `#UserApp.116`;
    in
    jump `#UserApp.105` `Bool.IdentId(38)`;

procedure : `pf..17` {}
procedure = `pf..17` (`pf..19`: {}, `#Attr.#arg_closure`: {}):
    let `pf..18` : {} = CallByName `pf.Stdout.3` `pf..19`;
    ret `pf..18`;

procedure : `List.getUnsafe` [C , C , C , C U64, C U64, C , C , C ]
procedure = `List.getUnsafe` (`#Attr.#arg1`: List [C , C , C , C U64, C U64, C , C , C ], `#Attr.#arg2`: U64):
    let `List.557` : [C , C , C , C U64, C U64, C , C , C ] = lowlevel ListGetUnsafe `#Attr.#arg1` `#Attr.#arg2`;
    ret `List.557`;

procedure : `List.update` List U8
procedure = `List.update` (`List.list`: List U8, `List.index`: U64, `List.func`: {}):
    inc `List.list`;
    let `List.537` : [C {}, C U8] = CallByName `List.get` `List.list` `List.index`;
    let `List.541` : U8 = 0i64;
    let `List.542` : U8 = GetTagId `List.537`;
    let `List.543` : Int1 = lowlevel Eq `List.541` `List.542`;
    if `List.543` then
        ret `List.list`;
    else
        let `List.value` : U8 = UnionAtIndex (Id 1) (Index 0) `List.537`;
        let `List.newValue` : U8 = CallByName `#UserApp.73` `List.value`;
        let `List.540` : {List U8, U8} = CallByName `List.replaceUnsafe` `List.list` `List.index` `List.newValue`;
        let `List.539` : List U8 = StructAtIndex 0 `List.540`;
        ret `List.539`;

procedure : `List.reserve` List U8
procedure = `List.reserve` (`#Attr.#arg1`: List U8, `#Attr.#arg2`: U64):
    let `List.564` : List U8 = lowlevel ListReserve `#Attr.#arg1` `#Attr.#arg2`;
    ret `List.564`;

procedure : `List.append` List [C , C , C , C U64, C U64, C , C , C ]
procedure = `List.append` (`List.list`: List [C , C , C , C U64, C U64, C , C , C ], `List.element`: [C , C , C , C U64, C U64, C , C , C ]):
    let `List.595` : U64 = 1i64;
    let `List.594` : List [C , C , C , C U64, C U64, C , C , C ] = CallByName `List.reserve` `List.list` `List.595`;
    let `List.593` : List [C , C , C , C U64, C U64, C , C , C ] = CallByName `List.appendUnsafe` `List.594` `List.element`;
    ret `List.593`;

procedure : `List.appendUnsafe` List [C , C , C , C U64, C U64, C , C , C ]
procedure = `List.appendUnsafe` (`#Attr.#arg1`: List [C , C , C , C U64, C U64, C , C , C ], `#Attr.#arg2`: [C , C , C , C U64, C U64, C , C , C ]):
    let `List.567` : List [C , C , C , C U64, C U64, C , C , C ] = lowlevel ListAppendUnsafe `#Attr.#arg1` `#Attr.#arg2`;
    ret `List.567`;

procedure : `#UserApp.getUnsafe` [C , C , C , C U64, C U64, C , C , C ]
procedure = `#UserApp.getUnsafe` (`#UserApp.list`: List [C , C , C , C U64, C U64, C , C , C ], `#UserApp.index`: U64):
    let `#UserApp.206` : [C {}, C [C , C , C , C U64, C U64, C , C , C ]] = CallByName `List.get` `#UserApp.list` `#UserApp.index`;
    let `#UserApp.210` : U8 = 0i64;
    let `#UserApp.211` : U8 = GetTagId `#UserApp.206`;
    let `#UserApp.212` : Int1 = lowlevel Eq `#UserApp.210` `#UserApp.211`;
    if `#UserApp.212` then
        let `#UserApp.208` : Str = "Out of bounds";
        Crash `#UserApp.208`
    else
        let `#UserApp.val` : [C , C , C , C U64, C U64, C , C , C ] = UnionAtIndex (Id 1) (Index 0) `#UserApp.206`;
        ret `#UserApp.val`;

procedure : `pf.Stdout.3` {}
procedure = `pf.Stdout.3` (`pf.Stdout.12`: {}):
    let `pf.Stdout.14` : {} = Struct {};
    ret `pf.Stdout.14`;

procedure : `List.reserve` List U64
procedure = `List.reserve` (`#Attr.#arg1`: List U64, `#Attr.#arg2`: U64):
    let `List.589` : List U64 = lowlevel ListReserve `#Attr.#arg1` `#Attr.#arg2`;
    ret `List.589`;

procedure : `#UserApp.print0to999` Str
procedure = `#UserApp.print0to999` ():
    let `#UserApp.306` : Str = "++++++++++\n>++++++++++++++++++++++++++++++++++++++++++++++++\n>++++++++++\n[\n\n  >++++++++++++++++++++++++++++++++++++++++++++++++\n  >++++++++++\n  [\n\n    >++++++++++++++++++++++++++++++++++++++++++++++++\n    >++++++++++\n    [\n      <<<<<.\n      >>.\n      >>.+\n      <<<<<.\n      >>>>>>-\n    ]\n    <----------------------------------------------------------\n\n    <<+\n    >-\n  ]\n  <----------------------------------------------------------\n\n  <<+\n  >\n  -\n]";
    ret `#UserApp.306`;

procedure : `List.update` List U8
procedure = `List.update` (`List.list`: List U8, `List.index`: U64, `List.func`: {}):
    inc `List.list`;
    let `List.521` : [C {}, C U8] = CallByName `List.get` `List.list` `List.index`;
    let `List.526` : U8 = 0i64;
    let `List.527` : U8 = GetTagId `List.521`;
    let `List.528` : Int1 = lowlevel Eq `List.526` `List.527`;
    if `List.528` then
        ret `List.list`;
    else
        let `List.value` : U8 = UnionAtIndex (Id 1) (Index 0) `List.521`;
        let `List.newValue` : U8 = CallByName `#UserApp.70` `List.value`;
        let `List.524` : {List U8, U8} = CallByName `List.replaceUnsafe` `List.list` `List.index` `List.newValue`;
        let `List.523` : List U8 = StructAtIndex 0 `List.524`;
        ret `List.523`;

procedure : `List.update` List [C , C , C , C U64, C U64, C , C , C ]
procedure = `List.update` (`List.list`: List [C , C , C , C U64, C U64, C , C , C ], `List.index`: U64, `List.func`: U64):
    inc `List.list`;
    let `List.544` : [C {}, C [C , C , C , C U64, C U64, C , C , C ]] = CallByName `List.get` `List.list` `List.index`;
    let `List.549` : U8 = 0i64;
    let `List.550` : U8 = GetTagId `List.544`;
    let `List.551` : Int1 = lowlevel Eq `List.549` `List.550`;
    if `List.551` then
        ret `List.list`;
    else
        let `List.value` : [C , C , C , C U64, C U64, C , C , C ] = UnionAtIndex (Id 1) (Index 0) `List.544`;
        let `List.newValue` : [C , C , C , C U64, C U64, C , C , C ] = CallByName `#UserApp.56` `List.value` `List.func`;
        let `List.547` : {List [C , C , C , C U64, C U64, C , C , C ], [C , C , C , C U64, C U64, C , C , C ]} = CallByName `List.replaceUnsafe` `List.list` `List.index` `List.newValue`;
        let `List.546` : List [C , C , C , C U64, C U64, C , C , C ] = StructAtIndex 0 `List.547`;
        ret `List.546`;

procedure : `pf.Effect.map` {Str, {}}
procedure = `pf.Effect.map` (`pf.Effect.103`: Str, `pf.Effect.effect_map_mapper`: {}):
    let `pf.Effect.104` : {Str, {}} = Struct {`pf.Effect.103`, `pf.Effect.effect_map_mapper`};
    ret `pf.Effect.104`;

procedure : `List.repeat` List U8
procedure = `List.repeat` (`List.value`: U8, `List.count`: U64):
    let `List.610` : List U8 = CallByName `List.withCapacity` `List.count`;
    let `List.609` : List U8 = CallByName `List.repeatHelp` `List.value` `List.count` `List.610`;
    ret `List.609`;

procedure : `Num.isGte` Int1
procedure = `Num.isGte` (`#Attr.#arg1`: U64, `#Attr.#arg2`: U64):
    let `Num.305` : Int1 = lowlevel NumGte `#Attr.#arg1` `#Attr.#arg2`;
    ret `Num.305`;

procedure : `List.walkHelp` {U64, List [C , C , C , C U64, C U64, C , C , C ], List U64}
procedure = `List.walkHelp` (`List.currentState`: {U64, List [C , C , C , C U64, C U64, C , C , C ], List U64}, `List.element`: U8, `List.func`: {}):
    let `List.637` : {U64, List [C , C , C , C U64, C U64, C , C , C ], List U64} = CallByName `#UserApp.tokenizeOne` `List.currentState` `List.element`;
    ret `List.637`;

procedure : `List.appendUnsafe` List U64
procedure = `List.appendUnsafe` (`#Attr.#arg1`: List U64, `#Attr.#arg2`: U64):
    let `List.587` : List U64 = lowlevel ListAppendUnsafe `#Attr.#arg1` `#Attr.#arg2`;
    ret `List.587`;

procedure : `pf..11` {}
procedure = `pf..11` (`pf..13`: {}, `#Attr.#arg_closure`: {Str, {}}):
    let `pf..12` : {} = CallByName `pf.Effect.effect_map_inner` `pf..13` `#Attr.#arg_closure`;
    ret `pf..12`;

procedure : `List.get` [C {}, C U64]
procedure = `List.get` (`List.list`: List U64, `List.index`: U64):
    let `List.658` : U64 = CallByName `List.len` `List.list`;
    let `List.654` : Int1 = CallByName `Num.isLt` `List.index` `List.658`;
    if `List.654` then
        let `List.656` : U64 = CallByName `List.getUnsafe` `List.list` `List.index`;
        dec `List.list`;
        let `List.655` : [C {}, C U64] = TagId(1) `List.656`;
        ret `List.655`;
    else
        dec `List.list`;
        let `List.653` : {} = Struct {};
        let `List.652` : [C {}, C U64] = TagId(0) `List.653`;
        ret `List.652`;

procedure : `#UserApp.73` U8
procedure = `#UserApp.73` (`#UserApp.x`: U8):
    let `#UserApp.160` : U8 = 1i64;
    let `#UserApp.159` : U8 = CallByName `Num.sub` `#UserApp.x` `#UserApp.160`;
    ret `#UserApp.159`;

procedure : `#UserApp.pop` [C {}, C {U64, List U64}]
procedure = `#UserApp.pop` (`#UserApp.list`: List U64):
    inc `#UserApp.list`;
    let `#UserApp.280` : [C {}, C U64] = CallByName `List.last` `#UserApp.list`;
    let `#UserApp.284` : U8 = 0i64;
    let `#UserApp.285` : U8 = GetTagId `#UserApp.280`;
    let `#UserApp.286` : Int1 = lowlevel Eq `#UserApp.284` `#UserApp.285`;
    if `#UserApp.286` then
        dec `#UserApp.list`;
        let `#UserApp.x` : {} = UnionAtIndex (Id 0) (Index 0) `#UserApp.280`;
        let `#UserApp.281` : [C {}, C {U64, List U64}] = TagId(0) `#UserApp.x`;
        ret `#UserApp.281`;
    else
        let `#UserApp.elem` : U64 = UnionAtIndex (Id 1) (Index 0) `#UserApp.280`;
        let `#UserApp.rest` : List U64 = CallByName `List.dropLast` `#UserApp.list`;
        let `#UserApp.283` : {U64, List U64} = Struct {`#UserApp.elem`, `#UserApp.rest`};
        let `#UserApp.282` : [C {}, C {U64, List U64}] = TagId(1) `#UserApp.283`;
        ret `#UserApp.282`;

procedure : `List.getUnsafe` U8
procedure = `List.getUnsafe` (`#Attr.#arg1`: List U8, `#Attr.#arg2`: U64):
    let `List.534` : U8 = lowlevel ListGetUnsafe `#Attr.#arg1` `#Attr.#arg2`;
    ret `List.534`;

procedure : `#UserApp.56` [C , C , C , C U64, C U64, C , C , C ]
procedure = `#UserApp.56` (`#UserApp.op`: [C , C , C , C U64, C U64, C , C , C ], `#UserApp.pc`: U64):
    let `#UserApp.268` : [C , C , C , C U64, C U64, C , C , C ] = CallByName `#UserApp.patchJump` `#UserApp.pc` `#UserApp.op`;
    ret `#UserApp.268`;

procedure : `List.appendUnsafe` List U8
procedure = `List.appendUnsafe` (`#Attr.#arg1`: List U8, `#Attr.#arg2`: U8):
    let `List.562` : List U8 = lowlevel ListAppendUnsafe `#Attr.#arg1` `#Attr.#arg2`;
    ret `List.562`;
